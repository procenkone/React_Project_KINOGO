1. create store - const store = configureStore({
                      reducer: {
                          carReducer
                      }
                  })
2.create slice - name, initial, reducer(methods business logic), import reducer from store
тобто в слайсі прописуємо всю логіку і одним файлом передаєм в стор щоб всі його бачили

3.a. коли прописана бізнес логіка і нам треба відправити данні для обробки в логіку то за допомогою діспатчу її туди передаєм
   useDispatch({data})

3.b. а коли протрібно дістати данні вже оброблені то використовуємо юзСелектор
const obj = useSelektor(cтор=>стор.той редюсер з якого треба дістати данні)
тепер змінна obj буде містити весь обєкт initialState з відповідного слайсу
але в obj є поле cars тому можна зразу деструктуризовати - const {cars} = useSelector(store=>store['carReducer'])
///////////////////////////////////////////////////////////////////////////////////////////////////////


для асинхронних запросів нам протрібно в слайс імпортувати createAsyncThunk
експоруємо константу getAllCar яка буде результатом дії функції createAsyncThunk,
ця функція першим параметром передає назву 'carSlice/getAllCars',
другим параметром іде асинхронна функція async()=>{}
в асинхронну функцію записуєм try{
}catch(e){
}
вся логіка буде в трай кетчі.
в try авейтим наш сервіс по діставанню всіх машин:
const cars = await carsService.getAll()
і ретьорним наш cars. Але сам він не попаде в стейт, тому треба під редюсером
вставити екстраРедюсер extraReducers:{}, екстра редюсер в свою чергу дає змогу відловити всі життєві моменти
запросу.
першим параметром нашого ексраРедюсеру буде [getAllCars.pending] -  це назва нашої функції для
діставання всіх машин і через крапку - pending - це стан початку запросу...тобто загрузка, коли ще не отримані данні
а велью цього динамічного ключа буде функція яка приймає стейт і екшик:
(state,action)=>{ }.
другим параметром екстраРедюсеру є фулФілд:
 [getAllCars.fulfilled]:(state,action)=>{} - це коли данні прийшли
 і третім параметром виступає реджект - це помилки:[getAllCars.rejected]:(state,action)=>

 тепер можем в наш initialState добавити додаткові поля: status, error значення у яких поки буде null.

 В прарметрі пендінг доступаємось до стейту і до поля статус і присвоюєєм йому = 'pending чи loading',
 і на всякий випадок до поля ерор і даєм йому нал(на всяк випадок)

 в другому стані ми також доступаємось до стейту.статус і даєм йому = 'fulfilled'
 потім доступаємось до стейту.карс і присвоюєм йому екшин.пайлоад - це і є результат нашого запиту до апіхи.

 тепер щоб отримати ці данні в компоненті карс нам треба:
 1. звернутись до юзСелектора і зі стору взяти саме той редюсер який містить наш стейт
 const {cars, status, error} = useSelector(state=>state['carReducer'])
 але тепер можна дістати не тільки кари а і статус і ерору
 2. імпортнути діспатч і покласти його в змінну діспатч
 3. звернутись до юзЕфекту і відправити туди діспатч з викликом нашої функції для діставання всіх данних - dispatch(getAllCars())

 Маючи теппер в компоненті і карів і статус і ерору можна зробити перевірук:
 {status === 'pending'&& <h1>Loading</h1>} або щось інше, крутілку чи шось таке

повертаємось до нашого третього стану запросу - помилка:
прописуєм статус реджект -  state.status = 'rejected'
а для відловлювання помилки портібно другим параметром у нашій
асинхронній функції async (_,{rejectWithValue}) => { - але саме другим параметром
і щоб ми його отримали саме другим то перед ним постави нижнє підкресленн" _ "
тепер в кетчі ретурним rejectWithValue(e.message) в якому передамо нашу помилку - е.message
і якраз повернення цього методу і запише в екшин нашого третього стану
state.error = action.payload
і тепер в компоненті можна тепер вивести помилку
{error&&<h2>{error}</h2>}


